# C 語言陣列與指標題目詳解

## 題目 1
**題目：** 若 A[ ][ ]是一個 MxN 的整數陣列，右側程式片段用以計算 A 陣列每一列的總和，以下敘述何者正確？
```c
void main() {
    int rowsum = 0;
    for (int i=0; i<M; i=i+1) { 
        for (int j=0; j<N; j-j+1) {
            rowsum = rowsum + A[i][j];
        }
        printf("The sum of row %d is %d.\n", i, rowsum);
    }
}
```
**(A)第一列總和是正確，但其他列總和不一定正確 (B)程式片段在執行時，會產生錯誤(run-time error) (C)程式片段中，有語法上的錯誤 (D)程式片段會完成執行並正確印出每一列的總和。**

**正確答案：(A)**

**詳細解說：**
1. **程式碼分析**：
   - 外層迴圈：`for (int i=0; i<M; i=i+1)` - 正確，用於遍歷每一列
   - 內層迴圈：`for (int j=0; j<N; j-j+1)` - **有問題！**

2. **錯誤分析**：
   - `j-j+1` 這個表達式永遠等於 1
   - 這意味著 j 永遠被設為 1，而不是遞增
   - 內層迴圈會變成無窮迴圈，因為 j 永遠不會達到 N

3. **執行結果**：
   - 第一列（i=0）：會正確計算，但會陷入無窮迴圈
   - 其他列：永遠不會執行到
   - 因此第一列總和是正確的，但其他列總和不會被計算

4. **正確寫法應該是**：`j=j+1` 或 `j++`

---

## 題目 2
**題目：** 寫出以下程式執行後之輸出結果：
```c
#include <stdio.h>
main ()
{
    int i=0,n=0,sum=0,arr[4]={10,15,82,174};
    while (n>=0)
    {
        n=arr[i++];
        if (n>=100) return n ; 
        if (n>=50)
        {
            sum=sum+1000; 
            break;
        }
        if (n>=30) continue; 
        sum=sum+n;
    }
    printf("The sum is %d \n",sum);
}
```
**(A)1025 (B)1010 (C)1015 (D)1174。**

**正確答案：(A)**

**詳細解說：**
1. **變數初始化**：i=0, n=0, sum=0, arr[4]={10,15,82,174}

2. **第一次迴圈執行**：
   - `n=arr[i++]` → n=arr[0]=10, i變成1
   - `if (n>=100)` → 10>=100? 否
   - `if (n>=50)` → 10>=50? 否
   - `if (n>=30)` → 10>=30? 否
   - `sum=sum+n` → sum=0+10=10

3. **第二次迴圈執行**：
   - `n=arr[i++]` → n=arr[1]=15, i變成2
   - `if (n>=100)` → 15>=100? 否
   - `if (n>=50)` → 15>=50? 否
   - `if (n>=30)` → 15>=30? 否
   - `sum=sum+n` → sum=10+15=25

4. **第三次迴圈執行**：
   - `n=arr[i++]` → n=arr[2]=82, i變成3
   - `if (n>=100)` → 82>=100? 否
   - `if (n>=50)` → 82>=50? 是
   - `sum=sum+1000` → sum=25+1000=1025
   - `break` → 跳出迴圈

5. **輸出結果**：printf("The sum is %d \n",sum) → "The sum is 1025"

---

## 題目 3
**題目：** 要將陣列 pin[ ]的第 13 個元素的值指定為 100，下列哪一行敘述正確？
**(A)pin[12]=100; (B)pin[13]=100; (C)pin[14] =100; (D)pin[15] = 100;。**

**正確答案：(A)**

**詳細解說：**
1. **陣列索引概念**：
   - C 語言陣列索引從 0 開始計算
   - 第 1 個元素：pin[0]
   - 第 2 個元素：pin[1]
   - 第 n 個元素：pin[n-1]

2. **第 13 個元素**：
   - 第 13 個元素的索引 = 13 - 1 = 12
   - 因此是 pin[12]

3. **記憶體布局示意**：
   ```
   元素順序：  1   2   3   ...  13  ...
   陣列索引： [0] [1] [2] ... [12] ...
   ```

4. **常見錯誤**：
   - 初學者容易直接使用元素順序作為索引
   - 必須記住：**元素順序 = 索引 + 1**

---

## 題目 4
**題目：** 宣告一個陣列 Y[5]，其索引值最小為？
**(A)-1 (B)1 (C)0 (D)5。**

**正確答案：(C)**

**詳細解說：**
1. **C 語言陣列索引規則**：
   - 所有陣列的索引都從 0 開始
   - 這是 C 語言的基本特性

2. **陣列 Y[5] 的索引範圍**：
   - 最小索引：0
   - 最大索引：4
   - 總共 5 個元素：Y[0], Y[1], Y[2], Y[3], Y[4]

3. **與其他語言的差異**：
   - 某些語言（如 MATLAB）陣列索引從 1 開始
   - 但 C 語言始終從 0 開始

4. **記憶體角度**：
   - 陣列名稱代表起始位址
   - 索引 0 表示相對於起始位址的偏移量為 0

---

## 題目 5
**題目：** 宣告一個 4 列 5 行的二維陣列，則此陣列的元素個數有幾個？
**(A)30 (B)20 (C)50 (D)60。**

**正確答案：(B)**

**詳細解說：**
1. **二維陣列元素計算**：
   - 元素總數 = 列數 × 行數
   - 4 列 × 5 行 = 20 個元素

2. **二維陣列宣告**：
   ```c
   int arr[4][5];  // 4 列 5 行
   ```

3. **元素分布**：
   ```
   arr[0][0] arr[0][1] arr[0][2] arr[0][3] arr[0][4]  // 第1列
   arr[1][0] arr[1][1] arr[1][2] arr[1][3] arr[1][4]  // 第2列
   arr[2][0] arr[2][1] arr[2][2] arr[2][3] arr[2][4]  // 第3列
   arr[3][0] arr[3][1] arr[3][2] arr[3][3] arr[3][4]  // 第4列
   ```

4. **記憶體佔用**：
   - 如果是 int 型別（4 bytes），總記憶體 = 20 × 4 = 80 bytes

---

## 題目 6
**題目：** 下列這段程式碼片段的描述，何者錯誤？
```c
int k=10; 
int *p;
*p=100;
```
**(A)宣告一個整數變數 k，同時給定初始值為 10 (B)宣告一個指標變數 p (C)指標變數所指向的記憶體位置，存放的值是 100 (D)指標變數 p 有指向確切的記憶體位址。**

**正確答案：(D)**

**詳細解說：**
1. **程式碼分析**：
   - `int k=10;` ✓ 正確宣告整數變數 k 並初始化為 10
   - `int *p;` ✓ 正確宣告指標變數 p
   - `*p=100;` ⚠️ 危險操作！

2. **錯誤分析**：
   - 指標 p 被宣告但**未初始化**
   - p 包含隨機的記憶體位址（垃圾值）
   - `*p=100` 嘗試在未知位址寫入值 100

3. **潛在問題**：
   - **記憶體存取違規**：可能存取到不屬於程式的記憶體
   - **程式崩潰**：可能導致 Segmentation Fault
   - **未定義行為**：結果不可預測

4. **正確寫法**：
   ```c
   int k=10;
   int *p = &k;  // 讓 p 指向 k 的位址
   *p=100;       // 現在安全了
   ```

5. **選項分析**：
   - (A) ✓ 正確
   - (B) ✓ 正確
   - (C) ✓ 技術上正確（如果不考慮安全性）
   - (D) ✗ **錯誤**：p 沒有指向確切的記憶體位址

---

## 題目 7
**題目：** 有關 C 語言中陣列的描述，下列何者錯誤？
**(A)陣列是一種資料結構 (B)陣列的索引值最小為 1 (C)陣列會佔用記憶體連續的空間 (D)陣列名稱為第 1 個元素的位址。**

**正確答案：(B)**

**詳細解說：**
1. **選項分析**：
   - (A) ✓ **正確**：陣列確實是一種資料結構，用於存儲相同類型的多個元素
   - (B) ✗ **錯誤**：C 語言陣列索引從 0 開始，不是從 1 開始
   - (C) ✓ **正確**：陣列元素在記憶體中連續存放
   - (D) ✓ **正確**：陣列名稱等同於第一個元素（索引 0）的位址

2. **陣列索引詳解**：
   ```c
   int arr[5] = {10, 20, 30, 40, 50};
   // 索引：    0   1   2   3   4
   // 最小索引是 0，不是 1
   ```

3. **記憶體連續性**：
   ```
   記憶體位址： 0x1000  0x1004  0x1008  0x100C  0x1010
   陣列元素：   arr[0]  arr[1]  arr[2]  arr[3]  arr[4]
   ```

4. **陣列名稱作為指標**：
   ```c
   int arr[5];
   // arr 等同於 &arr[0]
   // 都指向陣列的起始位址
   ```

---

## 題目 8
**題目：** 在 C 語言中，指標變數 ptr 指向某一個整數變數，已知該指標的值為 0x1234，則 ptr+1 的值為何？
**(A)0x1235 (B)0x1236 (C)0x1237 (D)0x1238。**

**正確答案：(D)**

**詳細解說：**
1. **指標運算原理**：
   - 指標運算會自動考慮所指向資料型別的大小
   - `ptr + 1` 不是簡單的位址 + 1

2. **整數指標運算**：
   - `int` 型別通常佔用 4 個位元組
   - `ptr + 1` = ptr + (1 × sizeof(int)) = ptr + 4

3. **計算過程**：
   - ptr = 0x1234
   - ptr + 1 = 0x1234 + 4 = 0x1238

4. **不同資料型別的指標運算**：
   ```c
   char *p1 = (char*)0x1000;    // p1 + 1 = 0x1001 (+ 1 byte)
   int *p2 = (int*)0x1000;      // p2 + 1 = 0x1004 (+ 4 bytes)
   double *p3 = (double*)0x1000; // p3 + 1 = 0x1008 (+ 8 bytes)
   ```

5. **實際應用**：
   - 這個特性讓陣列遍歷變得簡單
   - `arr[i]` 等同於 `*(arr + i)`

---

## 題目 9
**題目：** 要循序讀取某陣列的所有元素，最適合使用 C 語言的哪一種結構？
**(A)if (B)switch (C)for (D)break。**

**正確答案：(C)**

**詳細解說：**
1. **迴圈結構比較**：
   - **for 迴圈**：最適合已知次數的重複操作
   - **while 迴圈**：適合條件控制的重複操作
   - **do-while 迴圈**：至少執行一次的重複操作

2. **陣列遍歷特性**：
   - 陣列大小通常已知
   - 需要從索引 0 到 n-1 依序存取
   - 這正是 for 迴圈的強項

3. **典型的陣列遍歷**：
   ```c
   int arr[10];
   for (int i = 0; i < 10; i++) {
       printf("%d ", arr[i]);  // 循序讀取
   }
   ```

4. **其他選項分析**：
   - (A) if：條件判斷，不是迴圈結構
   - (B) switch：多分支選擇，不適合重複操作
   - (D) break：跳出語句，不是控制結構

5. **for 迴圈的優勢**：
   - 初始化、條件檢查、遞增都在一行
   - 程式碼簡潔易讀
   - 不容易出現無窮迴圈

---

## 題目 10
**題目：** 一個一維陣列 int D[5]={34,21,54,69,2};下列哪一行程式敘述可以取得元素 69？
**(A)D[4] (B)*(D+3) (C)&(D+3) (D)*D。**

**正確答案：(B)**

**詳細解說：**
1. **陣列內容分析**：
   ```c
   int D[5] = {34, 21, 54, 69, 2};
   //索引：    0   1   2   3   4
   ```
   - 元素 69 位於索引 3

2. **各選項分析**：
   - (A) `D[4]`：取得索引 4 的元素 = 2 ❌
   - (B) `*(D+3)`：取得索引 3 的元素 = 69 ✓
   - (C) `&(D+3)`：取得索引 3 元素的位址，不是值 ❌
   - (D) `*D`：等同於 D[0]，取得索引 0 的元素 = 34 ❌

3. **指標與陣列的等價關係**：
   ```c
   D[3] ≡ *(D+3)  // 兩者完全等價
   ```

4. **記憶體視覺化**：
   ```
   位址：   0x1000  0x1004  0x1008  0x100C  0x1010
   元素：   D[0]    D[1]    D[2]    D[3]    D[4]
   值：     34      21      54      69      2
   
   D+3 指向 0x100C
   *(D+3) 取得 0x100C 位址的值 = 69
   ```

5. **重要概念**：
   - `D` 是陣列名稱，代表起始位址
   - `D+3` 是位址運算，指向第 4 個元素
   - `*(D+3)` 是解參考，取得該位址的值

---

## 題目 35 (範例詳解)
**題目：** 宣告某陣列 int arr[4]={1,2,3,4}，下列何者的值與 arr[3] 一樣？
**(A)*arr (B)*(arr+1) (C)*(arr+2) (D)*(arr+3)。**

**正確答案：(D)**

**詳細解說：**

### 1. 依陣列解釋
**變數定義**：
- arr 是陣列名，代表整個陣列的起始地址（即首元素 arr[0] 的地址），它是一個地址常量（不可修改）
- 例如，若 arr[0] 的地址為 0x1000，則：
  - arr[1] 地址 = 0x1000 + sizeof(int) = 0x1004
  - arr[2] 地址 = 0x1008  
  - arr[3] 地址 = 0x100C（假設 int 占 4 字節）

### 2. 依指標解釋
**指標與地址的關係**：
- arr 是首元素地址（&arr[0]），類型為 int*
- arr + n 表示偏移 n 個元素的地址，計算方式為：arr + n = arr + n * sizeof(int)
- 例如：
  - arr + 0 → 0x1000（指向 arr[0]）
  - arr + 3 → 0x100C（指向 arr[3]）

### 3. 題目選項解析：等價表示對比

| 選項 | 展開形式 | 地址計算 | 內容（值） | 是否等於 arr[3] |
|------|----------|----------|------------|----------------|
| **(A) *arr** | *(arr + 0) | 0x1000 | 1 | ❌（arr[0]） |
| (B) *(arr+1) | *(arr + 1) | 0x1004 | 2 | ❌（arr[1]） |
| (C) *(arr+2) | *(arr + 2) | 0x1008 | 3 | ❌（arr[2]） |
| (D) *(arr+3) | *(arr + 3) | 0x100C | 4 | ✅（arr[3]） |

### 4. 關鍵結論
**arr[3] 本質是指標運算的語法糖**，編譯器將其轉換為 *(arr + 3)。
因此，arr[3] 與 *(arr + 3) 完全等價，均訪問地址 0x100C 的內容 4。

